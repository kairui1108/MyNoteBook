# 设计模式

设计模式分为三种类型，共23种

- 创建型模式

  > 单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式

- 结构型模式

  > 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

- 行为型模式

  > 模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解析器模式、状态模式、策略模式、职责链模式（责任链模式）

## 创建型模式

- **单例模式**

  使用方法获取对象，保证内存中只有一个对象，节省资源

  > 使用场景：频繁进行创建销毁的对象、创建对象消耗资源过多、经常使用的对象（工具类对象、频繁访问数据库或文件的对象）

  1. 饿汉式

     - 构造器私有化，在类加载时创建实例
     - 没有lazy loading的效果
     - 避免了线程同步问题
     - 可能造成*内存浪费*

  2. 懒汉式

     - 构造器私有，调用*getInstance*时才创建实例，起到lazy loading效果，但是线程不安全。
     - 可以通过*同步方法*实现线程安全，但同时效率太低，实际开发中尽量不采用。
     - 双重检查（使用*同步代码块*，同步代码块内*再次*判断实例是否为null，volatile关键字），可以解决线程安全同时解决懒加载问题
     - 推荐使用双重检查

  3. 静态内部类

     - 构造器私有化，内部静态类内含有静态属性singleton

     - 外部类加载**不会导致内部类的加载**，从而实现懒加载的效果

     - 调用getInstance时导致内部类加载，类加载时线程安全的
     - 推荐

  4. 枚举

     - 通过枚举实现单例模式
     - 避免线程同步问题
     - 能防止反序列化重新创建新的对象
     - 推荐

- **工厂模式**

  将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目依赖关系的解耦，从而提高项目的扩展和维护性。

  1. 简单工厂模式(静态工厂模式)
     - 最简单实用的工厂模式
     - 定义了一个创建对象的类，由其来*封装实例化对象的行为*

  2. 工厂方法模式
     - 定义了一个创建对象的抽象方法，由子类决定要实例化的类
     - 将对象的实例化推迟到子类

  3. 抽象工厂模式
     - 定义了一个接口用于创建相关或有依赖关系的对象族，而无须指明具体的类
     - 整合简单工厂模式和工厂方法模式
     - 设计层面上，抽象工厂就是对简单工厂的进一步的抽象
     - 将工厂抽象成两层 AbsFactory（抽象工厂）和具体实现的工厂子类

- **原型模式**

  创建新对象比较复杂时，可以用原型模式简化创建过程，同时提高效率，不用初始化对象，动态获得对象运行时的状态

  - 原型模式是指用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象

  - 原理：通过将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来实现创建，即 .clone()

    - **浅拷贝**（默认clone方法）

      1. 基本数据类型的成员变量直接进行值传递
      2. 引用类型的成员变量拷贝的是引用地址

    - **深拷贝**

      1. 复制所有基本数据类型的成员变量值

      2. 为所有引用数据类型的成员变量申请存储空间，并复制引用类型成员变量所引用的对象，知道可达的所有对象

      3. 实现深拷贝的方式

         - *重写clone方法（引用对象多时比较麻烦）*

         - *通过序列化实现拷贝（推荐）*

- **建造者模式**

  - 建造者模式又叫生成器模式，可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方式可以构造出不同表现（属性）的对象

  - 允许用户通过指定的复杂对象的类型和内容就可以构建他们，不需要知道内部具体的细节

  - 四个角色

    - Product（产品）：具体的产品对象
    - Builder（抽象建造者）：创建product对象各个部件指定的 接口/抽象类
    - ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件
    - Director（指挥者）：构建一个使用builder 接口的对象，主要用于创建一个复杂的对象（隔离了客户与对象的生产过程，复杂控制产品对象的生产过程）

  - 注意事项

    1. client 不需要知道产品内部组成的细节，产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象

    2. 每个具体建造者相互独立，利于替换或增加建造者，通过不同具体建造者即可得到不同的产品对象

    3. 方便控制产品的创建过程，使得创建过程更加清晰

    4. 指挥者针对抽象建造者类编程，系统扩展方便，符合开闭原则

    5. 如果产品之间差异很大，不适合使用建造者模式

    6. *抽象工厂模式 & 建造者模式*

       > *抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品，具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。*

       

## 结构型模式

- **适配器模式**

  Adapter Pattern ，又叫包装器，将某个类的接口转换成客户端期望的另一个接口表示，目的是兼容性，让原本因接口不匹配不能一起工作的连个类可以一起工作

  1. 类适配器模式
     - Java单继承机制，类适配器继承src算是缺点，因为这要求dst必须是接口
     - src类的方法在Adapter中都会暴露出来，增加使用成本
     - 由于继承了src类，可以按需重写src类的方法，增强了Adapter的灵活性
  2. 对象适配器模式
     - 不再继承src类，而是持有src类的实例
     - 根据合成复用原则，使用关联关系替代继承关系
     - 使用成本更低，更灵活
  3. 接口适配器模式
     - 不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并提供默认实现（空方法），该抽象类子类再选择性地覆盖父类的方法实现需求
     - 适用于一个接口不想使用其所有方法的情况
  
- **桥接模式**

  -  将实现与抽象放在两个不同的类层次中，使得两个层次可以独立改变，提高系统的灵活性，有助于系统分层设计
  - 基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责
  - 替代多层继承方案，减少子类的个数，降低管理维护的成本
  - 适用于那些不希望使用继承或因为多层次继承导致类的个数急剧增加的系统

- **装饰者模式**

  - 动态的将新功能附加到对象上，在对象功能扩展方面，比继承更有弹性，体现开闭原则（ocp）
  - 原理类似打包快递，Component, Decorator(继承Component)

- **组合模式**

  - 又叫部分整体模式，创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系
  - 组合模式使得用户对单个对象和组合对象的访问具有一致性
  - 具有较强的扩展性，方便创建复杂的层次结构
  - 需要遍历组织机构，或者处理的对象具有属性结构时，非常适合使用组合模式
  - 要求较高的抽象性，如果节点和叶子有很多差异性的话，不适合使用组合模式

- **外观模式**

  - Facade，也叫“过程模式”
  - 外观模式为子系统的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口屏蔽内部子系统的细节，使得这一子系统更加容易使用
  - 系统需要进行分成设计时，可以使用Facade模式
  - 维护遗留的大型系统时(难以维护和扩展)，可以考虑为新系统提供一个Facade类

- **享元模式**

  - Flyweight Pattern,也叫蝇量模式（共享对象）
  - 运用共享技术有效的支持大量细粒度的对象
  - 常用于系统底层开发，解决系统的性能问题
  - 能解决重复对象的内存浪费的问题，系统中有大量相似对象，可以使用缓冲池，直接从缓冲池中获取
  - 经典应用场景
    - String常量池
    - 数据库连接池
    - 缓冲池
  - 享元模式提出两个要求：细粒度和共享对象。这里涉及到内部状态和外部状态，即将对象的信息分为两个部分，*内部状态和外部状态*
    - **内部状态**：对象共享出来的信息，存储在享元对象内部且**不会**随环境的改变而改变（围棋的颜色）
    - **外部状态**:  对象得以依赖的一个标记，是随环境改变而改变的，不可共享的状态（围棋的坐标）

- **代理模式**

  - 为对象提供一个替身，以控制对这个对象的访问。

  - 通过代理对象访问目标对象，可以在目标对象的实现基础上，增强二外的功能，扩展目标对象功能

  - 被代理对象可以是远程对象、创建开销大的对象或需要安全控制的对象

  - 代理模式的三种形式

    1. **静态代理**

       - 定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者继承相同的父类

    2. **动态代理**

       - 代理对象不需要实现接口，但是目标对象要实现接口，否则不是用动态代理

       - 利用JDK的API生成代理对象，动态的在内存中构建代理对象

         > java.lang.reflect.Proxy :  newProxyInstance(classloader, clazz, invocationHandler)

       - 也叫JDK代理、接口代理

    3. **Cglib代理**（内存中动态的创建对象，而不需要实现接口，属于动态代理）

       - 目标对象没有实现任何接口时，可以使用其子类来实现代理，因此也叫*子类代理*（不能是final类，或static方法）
       - 在内存中构建一个子类对象从而实现对目标对象功能的扩展（可以归属到动态代理）
       - Cglib是个高性能代码生成包，可以在运行期间扩展java类与实现java接口，广泛用于AOP框架，实现方法拦截
       - 底层是通过使用字节码处理框架*ASM*来**转换字节码并生成新的类**

       >  AOP的代理模式选择
       >
       > - 目标对象需要实现接口，用JDK代理
       > - 目标对象不需要实现接口，用Cglib代理

  - 几种变体

    1. 防火墙代理

       > 内外通过代理穿透防火墙，实现对公网的访问

    2. 缓存代理

       > 请求资源时，先从缓存代理中取，没有再通过公网或数据库取，再缓存

    3. 远程代理

       > 远程对象的本地代表，通过它可以把远程对象当本地对象来调用，远程代理通过网络和真正的远程对象沟通信息

    4. 同步代理

       > 多线程编程中，完成多线程间同步工作


## 行为型模式

- **模板模式**

  - 在一个抽象类中公开定义执行他的方法的模板，他的子类可以按需重写方法实现，但调用将以抽象类中定义的方式执行

  - 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤

  - 算法只存再一个地方也就是父类中，容易修改。需要修改时，只需要修改父类的模板方法或者已经实现的某些步骤

  - 一般的模板方法都加上final关键字

  - 使用场景：当某个过程需要执行一系列的步骤，这一系列的方法步骤基本相同，个别步骤实现时可能不同

    > 模板方法模式的父类中，可以定义一个方法，默认不做任何事（空实现），子类可以按需重写该方法，该方法称为“钩子”

- **命令模式**

  - 将***发起请求的对象和执行请求的对象解耦***，发起请求的对象是调用者，调用者不需要知道具体的执行者，只需调用命令对象的excute方法，命令对象起到桥梁的作用
  - 命令模式使得请求发送者和请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦
  - 容易设计一个命令队列，只要将命令对象放到队列中，就可以多线程的执行命令
  - 容易实现对命令的撤销和重做
  - 空命令也是一种设计模式，省去了判空的操作
  - *不足*：可能导致系统中有过多的具体命令类，增加系统的复杂度

- **访问者模式**

  - 封装一些用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
  - 主要将数据结构与数据操作分离，解决数据结构和操作的耦合性问题
  - 访问者模式的基本工作原理是在**被访问的类**中提供**接待访问者**的接口
  - 符合单一职责原则，具有优秀扩展性、灵活性
  - 访问者模式可以对功能进行统一，可以做报表，UI，拦截器，过滤器，适用于数据结构相对稳定的系统
  - 应用场景：需要对数据结构对象进行很多不同操作（这些操作彼此没有关联），同时需要避免这些操作污染这些对象的类，可以选用访问者模式
  - 缺点：
    - 具体元素对访问者公布细节，违背迪米特法则
    - 违背了依赖倒置原则，访问者依赖的是具体元素，而不是抽象元素

- **迭代器模式**

  集合元素是用不同的方式实现的，有数组，还有集合类等时，如果需要遍历需要多种方式，还会暴露内部结构，此时可以考虑迭代器模式

  - 提供一种遍历集合元素的**统一接口**，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，不会暴露内部的结构
  - 符合单一职责原则，在聚合类中，把迭代器分开，就是把管理对象集合和遍历对象集合的责任分开，这样集合改变时只会影响到集合对象，而如果遍历方式改变的话，只影响到了迭代器
  - 缺点：每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类

- **观察者模式**

  对象之间多对一的一种设计方案，被依赖的对象为Subject，依赖的对象是Observer，Subject通知Observer变化

  - 观察者模式类似订阅的业务
  - Subject 提供添加、移除和通知观察者（Observer）的接口
  - Observer：接收输入
  - 以集合的方式管理用户（Observer），包括注册，移除和通知
  - 增加观察者时，不需要直接修改Subject，遵循了OCP原则

- **中介者模式**

  - Mediator Pattern，用一个中介对象来封装一系列的对象交互
  - 中介者使各个对象***不需要显式地相互引用***，从而使其耦合松散，而且可以独立地改变它们之间的交互
  - 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦
  - 中介者承担了较多的责任，一旦中介者出现问题，整个系统都会收到影响
  - MVC中，Controller就充当了中介者的作用

- **备忘录模式**

  ​	备忘录对象主要用于记录一个对象的某种状态，或者某种数据，当要做回退时，可以从备忘录对象中获取原来的数据进行回复操作

  - Memento Pattern在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象外保存这个状态，这样以后就可以将该对象回复到原先保存的状态
  - 给用户提供了一种可以恢复状态的机制，可以方便回到某个历史状态
  - 为了节约内存，备忘录可以和原型模式配合使用

- **解释器模式**

  - 指定一个语言（表达式），定义它的方法的一种表示，并定义一个解释器，使用该解释器解释表达式
  - 应用场景：编译器、运算表达式计算、正则表达式、机器人
    - 应用可以将一个解释执行的语言中的句子表示为一个抽象语法树
    - 一些重复出现的问题可以用一种简单的语言来表示
    - 一个简单语法需要解释的场景

- **状态模式***code

  主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换，一个对象内在状态改变时，可以改变行为。

  - 代码具有很强的可读性，将每个状态的行为封装到对应的一个类中
  - 替代了if-else结构，方便维护
  - 应用场景：当一个事件或者对象有很多种状态时，状态之间会相互转换，对不同状态要求有不同的行为

- **策略模式**

  - 定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立与使用算法的客户
  - 把变化的代码从不变的代码中分离出来
  - 针对接口编程而不是具体类（定义了策略接口）
  - 多用组合/聚合，少用继承（通过组合的方式使用策略，用行为类组合，而不是行为的继承）
  - 体现ocp原则，不需要修改原有代码即可添加一种策略

- **职责链模式**

  - 为请求创建了一个接收者对象的链，对请求的发送者和接收者进行解耦
  - 职责链模式通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，会把相同的请求交给下一个接收者
  - 性能会受到影响，特别是链比较长的时候，因此需要控制链中最大节点数量，一般通过Handler中设置一个最大节点数量，超过最大数量时，不允许建立该链


